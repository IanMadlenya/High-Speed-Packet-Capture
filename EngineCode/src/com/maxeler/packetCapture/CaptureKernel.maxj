package com.maxeler.packetCapture;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.networking.types.EthernetRXType;
import com.maxeler.packetCapture.types.DFEPaddedStructType;
import com.maxeler.packetCapture.types.FrameTypes;

// packs as many rx frames into burst size and pad the remaining with EOF
class CaptureKernel extends Kernel
{

	CaptureKernel( KernelParameters parameters, FrameTypes types )
	{
		super(parameters);
		this.flush.disabled();

		EthernetRXType frameType = types.frameType;
		DFEPaddedStructType framePaddedType = types.framePaddedType;
		DFEStruct framePadded = framePaddedType.newPaddedInstance(this);

		NonBlockingInput<DFEStruct> in = io.nonBlockingInput("input", frameType, constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);

		framePadded.get("frame") <== in.data;

		io.output("packedFrame", framePadded, framePaddedType, in.valid);
	}
}
