package com.maxeler.packetCapture.prototype;

import static com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.sft;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.networking.v1.kernel_types.TCPType;

public class SenderKernel extends Kernel
{
	static final DFEStructType META_TYPE = new DFEStructType(sft("sof", dfeBool()), sft("eof", dfeBool()), sft("mod", dfeUInt(3)));
	static final int META_SIZE = (int) Math.ceil(META_TYPE.getTotalBits() / 8.0);

	public SenderKernel( KernelParameters parameters, final Types types )
	{
		super(parameters);
		flush.disabled();

		System.out.println("META_SIZE: " + META_SIZE);

		DFEType socketType = DFETypeFactory.dfeUInt(8);

		DFEVar count = control.count.simpleCounter(1);

		DFEVar inputEnable = count === 0;
		DFEStruct datumPadded = io.input("datumPadded", types.datumPaddedType, inputEnable);
		DFEVar socket = io.scalarInput("socket", socketType);
		DFEStruct datum = datumPadded["datum"];

		socket.simWatch("socket");
		datum.simWatch("datum");
		inputEnable.simWatch("inputEnable");
		count.simWatch("count");


		DFEStruct meta = META_TYPE.newInstance(this);
		meta["sof"] = datum[TCPType.SOF];
		meta["eof"] = datum[TCPType.EOF];
		meta["mod"] = datum[TCPType.MOD];

		DFEStruct frame = new TCPType().getDFEStructType().newInstance(this);

		DFEVar mod = count === 0 ? (META_SIZE % 8) : (DFEVar) datum[TCPType.MOD];

		int frameDataBits = frame[TCPType.DATA].getType().getTotalBits();
		DFEVar datumRaw = datum[TCPType.DATA].pack();
		DFEVar metaRaw = dfeRawBits(frameDataBits - META_TYPE.getTotalBits()).newInstance(this, 0).cat(meta.pack());
		DFEVar outData = (count === 0) ? metaRaw : datumRaw;

		// TODO: pack data into maximum tcp payload size for efficient data transfer
		frame[TCPType.SOF] <== constant.var(true);
		frame[TCPType.EOF] <== constant.var(true);
		frame[TCPType.MOD] <== mod;
		frame[TCPType.DATA] <== outData;
		frame[TCPType.SOCKET] <== socket;

		outData.simWatch("outData");
		frame.simWatch("frame");


//
//
//
//
//
//
//
//
//
//
//
//
//		DatumFrame datumFrame = new DatumFrame();
//		FrameData<DatumFrame> frame = new FrameData<DatumFrame>(this, datumFrame, new TCPType());
//		DFEVar datum = datumPadded.pack();
//		frame["datum"] <== datum;
//
////		frame["datum"] <== constant.var(dfeRawBits(128), new Bits(128, "FFFFFFFFFFFFFF0123456789ABCDEFFF"));
//
////		pushResetBetweenFrames(false);
////		DFEVar count = control.count.makeCounter(control.count.makeParams(128)).getCount();
////		popResetBetweenFrames();
////		frame["datum"] <== count.pack();
//
//		frame["datum"].simWatch("datum");
//
//		frame.linkfield[TCPType.SOCKET] <== socket;
////		if( datumFrame.isPadded() )
////		{
////			frame[DatumFrame.PAD_KEY] <== datumFrame.padType.newInstance(this, 0);
////		}

		io.output("frame", frame, frame.getType());
	}
}
