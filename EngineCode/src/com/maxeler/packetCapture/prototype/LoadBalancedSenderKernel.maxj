package com.maxeler.packetCapture.prototype;

import static com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType.sft;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.networking.v1.kernel_types.TCPType;

public class LoadBalancedSenderKernel extends Kernel
{
	static final DFEStructType HEADER_TYPE = new DFEStructType(sft("sof", dfeBool()), sft("eof", dfeBool()), sft("mod", dfeUInt(3)));
	static final int HEADER_SIZE = (int) Math.ceil(HEADER_TYPE.getTotalBits() / 8.0);

	public LoadBalancedSenderKernel( KernelParameters parameters, final Types types, int serverCountMax )
	{
		super(parameters);
		flush.disabled();

		DFEType socketType = DFETypeFactory.dfeUInt(8);

		DFEVar serverCount = io.scalarInput("serverCount", dfeUInt(MathUtils.bitsToRepresent(serverCountMax)));
		DFEVar packetCounterEnable = dfeBool().newInstance(this);
		Params params = control.count.makeParams(MathUtils.bitsToAddress(serverCountMax)).withEnable(packetCounterEnable).withMax(serverCount);
		Counter packetCounter = control.count.makeCounter(params);
		DFEVar serverSelect = packetCounter.getCount();

		params = control.count.makeParams(1);
		Counter modeCounter = control.count.makeCounter(params);
		DFEVar modeCount = modeCounter.getCount();

		// input streams
		DFEVar inputEnable = modeCount === 0;
		DFEStruct datumPadded = io.input("datumPadded", types.datumPaddedType, inputEnable);
		DFEVar sockets[] = new DFEVar[serverCountMax];
		for( int i=0; i<serverCountMax; i++ )
		{
			String name = "socket" + i;
			DFEVar socket = io.scalarInput(name, socketType);
			socket.simWatch("socket" + i);
			sockets[i] = socket;
		}

		DFEVar serverSocket = control.mux(serverSelect, sockets);
		DFEStruct datum = datumPadded["datum"];

		// create header
		DFEStruct header = HEADER_TYPE.newInstance(this);
		header["sof"] = datum[TCPType.SOF];
		header["eof"] = datum[TCPType.EOF];
		header["mod"] = datum[TCPType.MOD];

		// sim watches
		datum.simWatch("datum");
		inputEnable.simWatch("inputEnable");
		modeCount.simWatch("modeCount");
		packetCounterEnable.simWatch("packetCounterEnable");
		serverSelect.simWatch("serverSelect");
		serverSocket.simWatch("serverSocket");

		packetCounterEnable <== ((DFEVar) datum[TCPType.EOF] === 1) & modeCounter.getWrap();

		DFEStruct frame = new TCPType().getDFEStructType().newInstance(this);

		DFEVar mod = modeCount === 0 ? (HEADER_SIZE % 8) : (DFEVar) datum[TCPType.MOD];

		// select frame header or frame datum for emission
		int frameDataBits = frame[TCPType.DATA].getType().getTotalBits();
		DFEVar datumRaw = datum[TCPType.DATA].pack();
		DFEVar metaRaw = dfeRawBits(frameDataBits - HEADER_TYPE.getTotalBits()).newInstance(this, 0).cat(header.pack());
		DFEVar outData = (modeCount === 0) ? metaRaw : datumRaw;

		// emit
		// TODO: pack data into maximum tcp payload size for efficient data transfer
		frame[TCPType.SOF] <== constant.var(true);
		frame[TCPType.EOF] <== constant.var(true);
		frame[TCPType.MOD] <== mod;
		frame[TCPType.DATA] <== outData;
		frame[TCPType.SOCKET] <== serverSocket;

		outData.simWatch("outData");
		frame.simWatch("frame");

		io.output("frame", frame, frame.getType());
	}
}
